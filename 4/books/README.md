# C Primer Plus


C语言眼看就快学1年了，
自己似乎还没学到什么，
期末项目又是很难的。
本学期还增加了java，
但是基础是同质的。
为了巩固，
我准备疯狂抽时间看《C Primer Plus》
同时记下自己遗漏的知识点！！！
现在是四月的尾巴，
希望能在5月中旬把它看完一遍，
我相信这会非常有用，
如果做到了，
这是我自身的一个挑战！！！



（因为是拾遗，所以暂时不成体系）
2020.5.1

1.	其一，储存在计算机中的所有内容都是数字。计算机以数字形式储存数字和字符（如，在文本文档中使用的字母）。每个字符都有一个数字码。计算机载入寄存器的指令也以数字形式储存，指令集中的每条指令都有一个数字码。
其二，计算机程序最终必须以数字指令码（即，机器语言）来表示。
2.	美国国家标准协会（ANSI）于 1983 年组建了一个委员会（X3J11），开发了一套新标准，并于1989年正式公布。该标准（ANSI C）定义了C语言和C标准库。
国际标准化组织于1990年采用了这套C标准（ISO C）。ISO C和ANSI C是完全相同的标准。
ANSI/ISO标准的最终版本通常叫作C89（因为ANSI于1989年批准该标准）或C90（因为ISO于1990年批准该标准）。
另外，由于ANSI先公布C标准，因此业界人士通常使用ANSI C。
3.	但并非所有的编译器都完全实现C99的所有改动。因此，你可能发现C99的一些改动在自己的系统中不可用，或者只有改变编译器的设置才可用。
4.	首先自己要明确自己想做什么思考你的程序需要哪些信息，要进行哪些计算和控
制，以及程序应该要报告什么信息
5.	考虑如何用程序来完成它。例如，用户界面应该是怎样的？如何组织程序？目标用户是谁？准备花多长时间来完成这个程序？
除此之外，还要决定在程序（还可能是辅助文件）中如何表示数据，以及用什么方法处理数据。
6.	不同的计算机使用不同的机器语言方案。C 编译器负责把C代码翻译成特定的机器语言。
此外，C编译器还将源代码与C库（库中包含大量的标准函数供用户使用，如printf()和scanf()）的代码合并成最终的程序（更精确地说，应该是由一个被称为链接器的程序来链接库函数，但是在大多数系统中，编译器运行链接器）。
（链接器的作用是，把你编写的目标代码、系统的标准启动代码和库代码这 3 部分合并成一个文件，即可执行文件）
其结果是，生成一个用户可以运行的可执行文件，其中包含着计算机能理解的代码
7.	当你把所学的知识应用于编程时，最好为自己会犯错做好心理准备。随着你越来越老练，你所写的程序中的错误也会越来越不易察觉
8.	有时，要在不同的步骤之间往复要编写的程序越大越复杂，事先定义和设计程序环节的工作量就越大。
养成先规划再动手编写代码的好习惯，用纸和笔记录下程序的目标和设计框架
9.	如果原始程序有多个源代码文件，则保留目标代码文件。
10.	第1个getchar()读取Enter键，第2个getchar()会导致程序暂停，直至用户再次按下Enter键。
11.	通常，通过按下标有 Enter、c/r、Return 或一些其他文字的键来发送指令。本书将这些按键统一称为Enter键。本书使用[enter]显式标出Enter键。
12.	#include <stdio.h>的作用相当于把stdio.h文件中的所有内容都输入该行所在的位置。实际上，这是一种“拷贝-粘贴”的操作。
13.	圆括号有什么功能？用于识别main()是一个函数。第11章将介绍把信息从main()函数传回操作系统的另一种形式
14.	分号在C语言中是大部分语句和声明的一部分，分号告诉编译器一条语句在哪里结束、下一条语句在哪里开始
15.	首次使用变量之前一定要先声明它，声明变量会促使你在编写程序之前做一些计划。
16.	〔在C语言中，实际参数（简称实参）是传递给函数的特定值，形式参数（简称形参）是函数中用于储存值的变量。
17.	转义序列用于代表难以表示或无法输入的字符
18.	%d相当于是一个占位符，其作用是指明输出num值的位置。
19.	强烈建议读者养成在 main()函数中保留 return 语句的好习惯
20.	待打印的值不一定是变量，只要可求值得出合适类型值的项即可
21.	语法错误：
实际上，有时不用把编译器报告的所有错误逐一修正，仅修正第 1 条或前几处错误后，错误信息就会少很多。继续这样做，直到编译器不再报错。
请检查上一行
22.	语义错误：
把自己想象成计算机，跟着程序的步骤一步一步地执行
要尽量忠实代码来模拟
在程序中的关键点插入额外的  printf()语句
使用调试器
23.	C语言并没有所谓的“赋值语句”，C语言是通过赋值运算符而不是赋值语句完成赋值操作。更一般地说，把值赋给存储空间。
24.	C标准中从来没有函数调用语句。函数调用本身是一个表达式，圆括号是运算符，圆括号左边的函数名是运算对象。这样的“函数调用语句”实质是表达式语句。
25.	如果数据是常量，编译器一般通过用户书写的形式来识别类型
八进制和十六进制常量被视为int类型。如果值太大，编译器会尝试使用unsigned int。如果还不够大，编译器会依次使用long、unsigned long、longlong和unsigned long long类型

26.	_Bool类型表示布尔值（true或false），_complex和_Imaginary分别表示复数和虚数
27.	最小的存储单元是位（bit），可以储存0或1
字节（byte）是常用的计算机存储单位。对于几乎所有的机器，1字节均为8位。
字（word）是设计计算机时给定的自然存储单位。计算机的字长越大，其数据转移越快，允许的内存访问也更多。
28.	浮点数通常只是实际值的近似值。例如，7.0可能被储存为浮点值6.99999。
	对于一些算术运算（如，两个很大的数相减），浮点数损失的精度更多。

29.	一般而言，系统用一个特殊位的值表示有符号整数的正负号。第15章将介绍常用的方法。
30.	最好不要把初始化的变量和未初始化的变量放在同一条声明中
31.	格式化字符串中的每个%d都与待打印变量列表中相应的int值匹配。这个值可以是int类型的变量、int类型的常量或其他任何值为int类型的表达式。
32.	0x或0X前缀表示十六进制值，0前缀表示八进制。
以八进制显示数字，使用%o。以十六进制显示数字，使用%x。
要显示各进制数的前缀0、0x和0X，必须分别使用%#o、%#x、%#X
33.	在实际使用中，有些类型之间通常有重叠。
C 标准对基本数据类型只规定了允许的最小大小
34.	使用short：
1.	当程序使用相对于系统可用内存较大的整型数组时，才需要重点考虑节省空间的问题
2.	计算机中某些组件使用的硬件寄存器是16位
35.	注意，当i超出（溢出）其相应类型所能表示的最大值时，系统并未通知用户。因此，在编程时必须自己注意这类问题。溢出行为是未定义的行为，C 标准并未定义有符号类型的溢出规则。
36.	对于short类型，可以使用h前缀，使用h修饰符可以显示较大整数被截断成 short 类型值的情况。
37.	对于无符号变量 un，使用%d会生成负值！其原因是，无符号值 3000000000
和有符号值−129496296  在系统内存中的内部表示完全相同（详见第15章）
38.	在给函数传递参数时，C编译器把short类型的值自动转换成int类型的值。int类型被认为是计算机处理整数类型时最高效的类型。
39.	从技术层面看，
40.	char是整数类型。因为char类型实际上储存的是整数而不是字符。计算机使
41.	用数字编码来处理字符，即用特定的整数表示特定的字符。
42.	C语言把1字节定义为char类型占用的位（bit）数，因此无论是16位还是32位系统，都可以使用char类型。
43.	利用字符常量的这种特性，可以定义一个字符常量'FATE'，即把4个独立的8位ASCII码储存在一个32位存储单元中。如果把这样的字符常量赋给char类型变量grade，只有最后8位有效。因此，grade的值是'E'。
44.	标准中的活跃位置（active position）指的是显示设备（屏幕、电传打字机、打印机等）中下一个字符将出现的位置。简而言之，平时常说的屏幕光标位置就是活跃位置
45.	回车符（\r）把活跃位置移动到当前行的开始处
46.	换页符和垂直制表符只有将其输出到打印机上时才会产生前面描述的效果。
47.	如果要用八进制ASCII码表示一个字符，可以在编码值前面加一个反斜杠（\）并用单引号括起来。可以省略前面的 0，'\07'甚至'\7'都可以。即使没有前缀 0，编译器在处理这种写法时，仍会解释为八进制。
48.	反斜杠后面跟一个x或X，再加上1～3位十六进制数字
49.	数字和数字字符的区别，字符4对应的ASCII码是52。'4'表示字符4，而不是数值4
50.	无论是普通字符还是转义序列，只要是双引号括起来的字符集合，就无需用单引号括起来
51.	如果要使用ASCII码，为何要写成'\032'而不是032？首先，'\032'能更清晰地表达程序员使用字符编码的意图。其次，类似\032这样的转义序列可以嵌入C的字符串中，如printf("Hello!\007\n");中就嵌入了\007
52.	如果用%d转换说明打印 char类型变量的值，打印的是一个整数。而%c转换说明告诉printf()打印该整数值对应的字符。
53.	注意，printf()函数中的转换说明决定了数据的显示方式，而不是数据的储存方式
54.	signed  char表示有符号类型，而unsigned  char表示无符号类型。这在用char类型处理小整数时很有用
55.	C语言用值1表示true，值0表示false，所以_Bool类型实际上也是一种整数类型。但原则上它仅占用1位存储空间
56.	在C语言中，可以把多个连续的字符串组合成一个字符串
57.	float类型必须至少能表示6位有效数字，且取值范围至少是10 -37 ～10 +37，必须至少精确表示小数点后的6位有效数字
58.	double类型和float类型的最小取值范围相同，但至少必须能表示10位有效数字，double类型的值至少有13位有效数字，超过了标准的最低位数规定
59.	可以没有小数点（如，2E5）或指数部分（如，19.28），但是不能同时省略两者
60.	不要在浮点型常量中间加空格
61.	在浮点数后面加上f或F后缀可覆盖默认设置，编译器会将浮点型常量看作float类型
62.	用p和P分别代替e和E，用2的幂代替10的幂（即，p计数法）
63.	用%e打印指数记数法的浮点数，如果系统支持十六进制格式的浮点数，可用a和A分别代替e和E
64.	这是一个上溢（overflow）的示例。当计算导致数字过大，超过当前类型能表达的范围时，就会发生上溢。而且printf()显示该值为inf或infinity（或者具有无穷含义的其他内容）。
C语言把损失了类型全精度的浮点值称为低于正常的（subnormal）浮点值
特殊的浮点值NaN
65.	C语言有3种复数类型：float_Complex、double_Complex和long double _Complex。例如，float _Complex类型的变量应包含两个float类型的值，分别表示复数的实部和虚部。
3种虚数类型是float_Imaginary、double _Imaginary和long double _Imaginary
如果包含complex.h头文件，便可用complex代替_Complex，用imaginary
代替_Imaginary，还可以用I代替-1的平方根
66.	sizeof是C语言的内置运算符，以字节为单位给出指定类型的大小。C99和C11提供%zd转换说明匹配sizeof的返回类型
67.	printf()语句都被分为两行，只要不在引号内部或一个单词中间断行，就可以这样写。
68.	会直接丢弃（截断）小数部分，而不进行四舍五入
69.	许多程序员和公司内部都有系统化的命名约定，在变量名中体现其类型
70.	7个退格字符\b使得光标左移7个位置，即把光标移至7个下划线字符的前面，紧跟在美元符号后面。通常，退格不会擦除退回所经过的字符，但有些实现是擦除的，这和本例不同。
71.	\n使光标移至下一行的起始处
72.	何时把缓冲区中的内容发送到屏幕：当缓冲区满、遇到换行字符或需要输入的时候
从缓冲区把数据发送到屏幕或文件被称为刷新缓冲区
还有一种刷新缓冲区的方法是使用fflush()函数，详见第13章。


【今天是5月19日，总是习惯于辜负自己，但是不能破罐子破摔啊，我得思索总结，然后再站起来向前冲】

73.	scanf()只读取了Angela  Plains中的Angela，它在遇到第1个空白（空格、制表符或换行符）时就不再读取输入
74.	字符串是派生类型
75.	对于类型，应写成sizeof(char)或sizeof(float)；
对于特定量，可写成sizeof name或sizeof 6.28。
尽管如此，还是建议所有情况下都使用圆括号，如sizeof(6.28)。
76.	预处理器也可用来定义常量。编译程序时，程序中所有的TAXRATE都会被替换成0.015。这一过程被称为编译时替换（compile-time substitution）。在运行程序时，程序中所有的替换均已完成（见图  4.5）。通常，这样定义的常量也称为明示常量。
77.	const用起来比#define更灵活，第12章将讨论与const相关的内容。
78.	C提供了可移植性更好的类型。首先，stddef.h头文件（在包含stdio.h头文件时已包含其中）把size_t定义成系统使用sizeof返回的类型，这被称为底层类型（underlying type）。其次，printf()使用z修饰符表示打印相应的类型。同样，C还定义了ptrdiff_t类型和t修饰符来表示系统使用的两个地址差值的底层有符号整数类型
79.	一般而言，ANSI  C不会把float自动转换成double。然而，为保护大量假设float类型的参数被自动转换成double的现有程序，printf()函数中所有float类型的参数（对未使用显式原型的所有C函数都有效）仍自动转换成double类型。
80.	转换说明是翻译说明，%d的意思是“把给定的值翻译成十进制整数文本并打印出来
81.	而数字32768～65535则表示负数。其中，65535表示-1，65534表示-2，以此类推
82.	问题出在C如何把信息传递给函数。具体情况因编译器实现而异。
83.	如果空白（空格、制表符、换行符）仅用于分隔不同的部分，C 编译器会忽略它们
84.	给字符串断行有3种方法：
方法1：使用多个printf()语句。
方法2：用反斜杠（\）和Enter（或Return）键组合来断行。这使得光标移至下一行，而且字符串中不会包含换行符。其效果是在下一行继续输出。但是，下一行代码必须和程序清单中的代码一样从最左边开始。如果缩进该行，比如缩进5个空格，那么这5个空格就会成为字符串的一部分
方法3：ANSI C引入的字符串连接。在两个用双引号括起来的字符串之间用空白隔开，C编译器会把多个字符串看作是一个字符串
85.	只要在每个输入项之间输入至少一个换行符、空格或制表符即可。把输入分成多个字段。在依次把转换说明和字段匹配时跳过空白。唯一例外的是%c转换说明。根据%c，scanf()会读取每个字符，包括空白。
86.	对于float类型和double类型，printf()都使用%f、%e、%E、%g和%G转换说明。而scanf()只把它们用于float类型，对于double类型时要使用l修饰符。
87.	scanf()函数返回成功读取的项数。如果没有读取任何项，且需要读取一个数字而用户却输入一个非数值字符串，scanf()便返回0。
当scanf()检测到“文件结尾”时，会返回EOF（EOF是stdio.h中定义的特殊值，通常用#define指令把EOF定义为-1）。可使用scanf()的返回值来检测和处理不匹配的输入
88.	如果转换说明是%*d，那么参数列表中应包含*和 d对应的值。这个技巧也可用于浮点值指定精度和字段宽度。
scanf()中*的用法与此不同。把*放在%和转换字符之间时，会使得scanf()跳过相应的输出项。
89.	
